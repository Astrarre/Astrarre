subprojects {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    group = 'io.github.astrarre'
    plugins.apply 'java'
    plugins.apply 'java-library'
    plugins.apply 'maven-publish'
    plugins.apply "amalgamation-minecraft"
}

task remapAll(type: RemapAllJars) {
}
task remapAllSources(type: RemapAllSourcesJars) {
}

def intermediaryMinecraft = ag.map {
    mappings(ag.intermediary(minecraft_version))
    inputGlobal(ag.mojmerged(minecraft_version))
}

def mc
def fapi
def reiImpl
def map = "net.fabricmc:yarn:${yarn_mappings}:v2"
def libs = ag.libraries(minecraft_version)
def floader = ag.fabricLoader("0.12.5")
ag.map {
    mappings(map, 'intermediary', 'named')
    mc = inputGlobal(intermediaryMinecraft)
    fapi = inputLocal("net.fabricmc.fabric-api:fabric-api:${fabric_version}") {
        exclude module: 'fabric-loader'
    }
    reiImpl = inputLocal("me.shedaniel:RoughlyEnoughItems-fabric:7.0.346") {
        exclude group: "net.fabricmc.fabric-api"
        exclude module: 'fabric-loader'
    }
}

allprojects {
    ext.fabric = fapi
    ext.minecraft = mc
    ext.reiImpl = reiImpl
    ext.mcLibs = libs

    sourceSets { testmod {} }

    version vers

    repositories {
        mavenLocal()
        mavenCentral()
        maven { url 'https://maven.fabricmc.net/' }
        maven { url 'https://jitpack.io' }
        maven { url 'https://maven.legacyfabric.net/' }
        maven { url "https://maven.shedaniel.me/" }
    }

    configureCompile(project, "", map)
    configureCompile(project, "testmod", map)

    configurations {
        minecraftConfig {}
        implementation.extendsFrom(minecraftConfig)
    }

    dependencies {
        testImplementation('junit:junit:4.13.1') {
            exclude module: 'fabric-loader'
        }

        minecraftConfig floader
        minecraftConfig mcLibs

        implementation 'org.jetbrains:annotations:23.0.0'
        minecraftConfig map
        /*testImplementation('net.devtech:PotatoUnit:1.0.3') {
            exclude module: 'fabric-loader'
        }*/

        testmodImplementation(fapi)
    }

    sourceSets {
        testmod {
            compileClasspath += main.output + main.compileClasspath
            runtimeClasspath += main.runtimeClasspath
        }
        test {
            compileClasspath += main.output + main.compileClasspath
            runtimeClasspath += main.compileClasspath
        }
    }
    publishing {
        publications {
            mavenJava(MavenPublication) {
                artifactId = "$project.name-fabric"
                from components.java
                artifacts = []
                ag.excludeConfiguration(it, configurations.minecraftConfig)
                ag.fixPom(it)
                artifact(remapJar) {
                    builtBy remapJar
                }

                // sources for ye normal folk
                artifact(remapSourcesJar) {
                    builtBy remapSourcesJar
                }
            }
        }

        repositories {
            maven {
                def mavenUrl = project.hasProperty('maven_url') ? project.property('maven_url') : ""
                url mavenUrl
                if (mavenUrl.startsWith("http")) {
                    credentials {
                        username project.hasProperty('maven_username') ? project.property('maven_username') : ""
                        password project.hasProperty('maven_password') ? project.property('maven_password') : ""
                    }
                }
            }
        }
    }

    jar {
        from "$rootProject.projectDir/LICENSE"
    }

    task doNothing {}

    task runClient(type: JavaExec) {
        group = "Minecraft"
        description = "Test Diff:tm:"
        classpath sourceSets.testmod.runtimeClasspath
        main = "net.fabricmc.loader.launch.knot.KnotClient"
        def natives = ag.natives(minecraft_version)
        systemProperty("fabric.development", true)
        systemProperty("fabric.gameVersion", minecraft_version)
        systemProperty("java.library.globalCache", natives)
        systemProperty("org.lwjgl.librarypath", natives)
        def assets = ag.assets(minecraft_version)
        args("--assetIndex", assets.getAssetIndex(), "--assetsDir", assets.getAssetsDir())
        workingDir("$rootDir/run")
        dependsOn tasks.testmodClasses
    }
    /*ag.idea().java(runClient) {
        it.customName = name + "_runClient"
    }*/
}

void configureCompile(Project project, String str, String map) {
    def real = str.isEmpty() ? "main" : str
    def upper = str.isEmpty() ? "" : str.substring(0, 1).toUpperCase() + str.substring(1)
    project.configure(project) {
        tasks.getByName("process${upper}Resources") {
            inputs.property "version", project.version
            filesMatching("fabric.mod.json") {
                expand "version": project.version
            }
        }

        def remap = tasks.create(type: RemapJar, name: "remap${upper}Jar") {
            group = "build"
            if (str.isEmpty()) {
                with jar
            } else {
                from sourceSets.getByName(real).output
            }
            classpath = sourceSets.getByName(real).compileClasspath
            remapAw()
            useExperimentalMixinRemapper()
            mappings(map, 'named', 'intermediary')
        }

        def remapSources = tasks.create(type: RemapSourcesJar, dependsOn: classes, name: "remap${upper}SourcesJar") {
            group = "build"
            classifier = 'sources'
            from sourceSets.getByName(real).allSource
            classpath = sourceSets.getByName(real).compileClasspath
            mappings(map, 'named', 'intermediary')
        }

        if(upper.isEmpty()) {
            project.rootProject.tasks.remapAll.addTask(remap)
            project.rootProject.tasks.remapAllSources.addTask(remapSources)
        }
    }
}

def all = allprojects
int count = all.size()
allprojects {
    afterEvaluate {
        if(--count == 0) {
            all.each {
                def vers = computeVersion(it)
                it.version(vers)
                println("$it @ $vers")
            }
        }
    }
}

static def computeVersion(Project project) {
    List<Integer> versArr = (project.vers.split("\\.")).collect{ Integer.parseInt(it) }
    Task publish = project.tasks.publish, publishLocal = project.tasks.publishToMavenLocal
    def projectConsumer = {Project depProject ->
        depProject.tasks.publish.finalizedBy({publish})
        depProject.tasks.publishToMavenLocal.finalizedBy({publishLocal})
        List<Integer> versB = (computeVersion(depProject).split("\\.")).collect{ Integer.parseInt(it) }
        versB.eachWithIndex({val, i -> {
            if(i == 0) {
                versArr.set(1, versArr.get(i)+versArr.get(1)+val)
            } else {
                versArr.set(i, versArr.get(i)+val)
            }
        }})
    }
    if(project == project.rootProject) {
        project.subprojects.each(projectConsumer)
    } else {
        def copy = project.configurations.api.copy()
        copy.setCanBeResolved(true)
        copy.dependencies.forEach(d -> {
            if (d instanceof ProjectDependency) {
                projectConsumer(d.dependencyProject)
            }
        })
    }
    return versArr.join(".")
}