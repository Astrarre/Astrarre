buildscript {
    repositories {
        mavenCentral()
        mavenLocal()
        maven { url 'https://dl.bintray.com/astrarre/maven' }
    }

    dependencies {
        classpath 'io.github.astrarre:astrarre-stripper:1.1.3'
    }
}


import io.github.astrarre.stripper.gradle.StrippedJar
import net.fabricmc.loom.task.RemapJarTask
import org.gradle.api.internal.file.collections.FileTreeAdapter
import org.gradle.api.internal.file.collections.GeneratedSingletonFileTree
import org.gradle.api.internal.file.copy.CopySpecInternal

import java.util.stream.Collectors

plugins {
    id 'java'
    id 'idea'
    id 'eclipse'
    id 'java-library'
    id 'maven-publish'
    id "com.jfrog.bintray" version "1.8.4"
    id "fabric-loom" version "0.5.42"
}

version = project.mod_version

loom.runDir = "run"


def root = project
allprojects {
    plugins.apply('java')
    plugins.apply('idea')
    plugins.apply('eclipse')
    plugins.apply('java-library')
    plugins.apply('maven-publish')
    plugins.apply("com.jfrog.bintray")
    plugins.apply("fabric-loom")

    group "io.github.astrarre"
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    sourceSets {
        testmod {
            compileClasspath += main.compileClasspath
            runtimeClasspath += main.runtimeClasspath
        }
        abstracter {
            runtimeClasspath += root.configurations.minecraftNamed
            compileClasspath += root.configurations.minecraftNamed
        }
    }

    repositories {
        mavenLocal()
        mavenCentral()
        maven { url 'https://maven.fabricmc.net/' }
        maven { url 'http://maven.modmuss50.me/' }
        maven { url 'https://dl.bintray.com/astrarre/maven' }
        maven { url 'https://jitpack.io' }
    }

    dependencies {
        minecraft "com.mojang:minecraft:${root.minecraft_version}"
        mappings "net.fabricmc:yarn:${root.yarn_mappings}:v2"
        modImplementation "net.fabricmc:fabric-loader:${root.loader_version}"
        modImplementation "net.fabricmc.fabric-api:fabric-api:${root.fabric_version}"
        modImplementation "io.github.astrarre:astrarre-stripper:1.1.1"
        abstracterCompile "io.github.astrarre:abstracter:1.2.5"
    }

    jar {
        from "$root.projectDir/LICENSE"
    }

    loom {
        shareCaches = true
    }

    task sourcesJar(type: Jar) {
        group = "astrarre"
        archiveClassifier = "sources"
        from sourceSets.main.allSource
    }

    afterEvaluate {
        processResources {
            inputs.property "version", project.version

            from(sourceSets.main.resources.srcDirs) {
                include "fabric.mod.json"
                expand "version": project.version
            }

            from(sourceSets.main.resources.srcDirs) {
                exclude "fabric.mod.json"
            }
        }
    }
}

def hasAbstractions(Project proj) {
    println("$proj has abstractions!")
    proj.configure(proj) {
        task fakeImplJar(type: Jar) {
            archiveName 'fake_impl.jar'
            from zipTree("$proj.buildDir/abstracted/impl.jar")
            def jar = (CopySpecInternal) getRootSpec().addFirst().into("")
            jar.addChild().from {
                GeneratedSingletonFileTree artificalFabricModJson = new GeneratedSingletonFileTree(getTemporaryDirFactory(), "fabric.mod.json", {
                    it.write("{\"schemaVersion\": 1,\"id\":\"$proj.name-fake-impl\",\"version\": \"version\"}".bytes)
                })
                return new FileTreeAdapter(artificalFabricModJson)
            }
        }

        dependencies {
            runtimeOnly tasks.fakeImplJar.outputs.files
            compile files("$buildDir/abstracted/api.jar")
            testmodRuntimeOnly tasks.fakeImplJar.outputs.files
            testmodCompile files("$buildDir/abstracted/api.jar")
        }

        tasks.compileJava.dependsOn tasks.fakeImplJar

        task generateAbstractions(type: JavaExec) {
            group = "astrarre"
            description = "Runs the abstracter config class"
            classpath = sourceSets.abstracter.runtimeClasspath
            inputs.files classpath

            outputs.file "$buildDir/abstracted/api.jar"
            outputs.file "$buildDir/abstracted/api_sources.jar"
            outputs.file "$buildDir/abstracted/impl.jar"
            outputs.cacheIf { true }
            main = "Main"

            def file = new File(buildDir, "abstracter_gradle_info.properties")
            args file.absolutePath

            doFirst {
                new File(buildDir, "abstracted").mkdirs()
                if (!file.exists()) {
                    def properties = new Properties()
                    properties.setProperty("mappings", loom.getMappingsProvider().tinyMappings.absolutePath)
                    properties.setProperty("minecraft", configurations.minecraftNamed.resolve().last().absolutePath)
                    properties.setProperty("libraries", configurations.minecraftLibraries.resolve().stream().map() { it.absolutePath }.collect(Collectors.joining(";")))
                    properties.setProperty("api_jar", "$buildDir/abstracted/api.jar")
                    properties.setProperty("api_sources_jar", "$buildDir/abstracted/api_sources.jar")
                    properties.setProperty("impl_jar", "$buildDir/abstracted/impl.jar")
                    def out = new FileWriter(file)
                    properties.store(out, "Minecraft Libraries, Emitted by classes task")
                    out.close()
                }
            }
        }

        tasks.compileJava.dependsOn tasks.generateAbstractions
        tasks.fakeImplJar.dependsOn tasks.generateAbstractions
        // todo delete if unessary
        task implJar(type: Jar, dependsOn: jar) {
            group = "astrarre"
            classifier = "impl-dev"
            with jar
            from zipTree("$buildDir/abstracted/impl.jar")
        }

        afterEvaluate {
            RemapJarTask task = proj.tasks.remapJar
            task.input = implJar.outputs.files.first()
            task.dependsOn implJar
        }
    }
}

dependencies {
    afterEvaluate {
        subprojects.each {
            compile project(":${it.name}")
            include project("${it.name}:")
            testmodCompile project("${it.name}:").sourceSets.testmod.output
        }
    }
}

subprojects {
    dependencies {
        testmodCompile sourceSets.main.output
    }

    task stripJar(type: StrippedJar) {
        group = "astrarre"
        archiveClassifier = "stripped"
        from sourceSets.main.allSource
        with jar
    }

    task apiJar(type: Jar) {
        group = "astrarre"
        archiveClassifier = "api"
        with stripJar
        afterEvaluate {
            if (project.tasks.findByName("generateAbstractions") != null) {
                from zipTree("$buildDir/abstracted/api.jar")
                from zipTree("$buildDir/abstracted/api_sources.jar")
            }
        }
    }
}

task apiJar(type: Jar) {
    group = "astrarre"
    classifier = "api"
    subprojects.each {
        with it.tasks.apiJar {
            exclude "LICENSE"
        }
    }
    exclude("fabric.mod.json")
    from "LICENSE"
}

subprojects.each {
    apiJar.dependsOn it.tasks.apiJar
}

allprojects {
    // configure the maven publication
    publishing {
        publications {
            mavenJava(MavenPublication) {
                artifactId = "$project.name-fabric"
                // regular old implementation jar
                artifact(remapJar) {
                    builtBy remapJar
                }

                // sources for ye normal folk
                artifact(sourcesJar) {
                    builtBy remapSourcesJar
                }

                pom.withXml {
                    def depsNode = asNode().appendNode("dependencies")
                    subprojects.each {
                        def depNode = depsNode.appendNode("dependency")
                        depNode.appendNode("groupId", it.group)
                        depNode.appendNode("artifactId", "$it.name-fabric")
                        depNode.appendNode("version", it.version)
                        depNode.appendNode("scope", "runtime")
                    }
                }
            }

            mavenApi(MavenPublication) {
                artifactId = "$project.name-api"
                artifact(apiJar) {
                    builtBy apiJar
                }
            }
        }

        // select the repositories you want to publish to
        repositories {
            // uncomment to publish to the local maven
            mavenLocal()
        }
    }

    bintray {
        user = project.hasProperty('bintray_user') ? project.property('bintray_user') : ""
        key = project.hasProperty('bintray_api_key') ? project.property('bintray_api_key') : ""
        publications = ["mavenJava", "mavenApi"]
        publish = true
        //[Default: false] Whether version should be auto published after an upload
        pkg {
            repo = "maven"
            name = "astrarre-api"
            userOrg = "astrarre"
            licenses = ["LGPL-3.0"]
            version {
                name = version
                released = new Date()
            }
        }
    }
}